# About Us

- We are programmers
- We are web component enthusiasts
- We are believers of web standards
- We are hungry for knowledge
- We are open source
- We are the web
- We are humans
- [We are us](https://github.com/open-wc/open-wc/graphs/contributors)

[Join us!](https://github.com/open-wc/open-wc/)

## Why `open-wc`

We want to provide the community with well-known and experience-tested recommendations for their web component projects. Everything we do here is to encourage and support development with these open standards.

### Our Philosophy

The goal of Open Web Components is to empower developers with powerful and battle-tested tools for creating and sharing open source web components.

Many web developers have experienced the dreaded "Javascript Fatigue". With our recommendations, we hope you'll enjoy the peace of mind that comes from having a well-known default solution for almost everything. From IDE to CI, `open-wc` has got you covered.

We want web component development to be accessible and approachable for everyone, regardless of their background. Therefore, our recommendations aim to be easy to use, be ready to use, and provide that "it just works" developer experience we all crave for the various aspects of web component development.

Best practices/recommendations and examples may change and evolve over time.	

### Why Web Components

We believe that web components provide a standards-based solution to problems like reusability, interoperability, and encapsulation.

#### Historical Background

The World Wide Web was originally just text documents connected by hyperlinks. As technologies like JavaScript and techniques like <abbr title="Asynchronous JavaScript and XML">AJAX</abbr> and <abbr title="Representational State Transfer">REST</abbr> entered the picture, the web slowly developed into a platform for full-fledged application development.

At first, JavaScript libraries like jQuery were absolutely required. jQuery gave developers a common set of tools across browsers with extremely different feature sets. Eventually jQuery features became standard browser features. The pattern of libraries innovating and browsers subsequently standardizing continued. As the "[browser wars](https://www.wikiwand.com/en/Browser_wars)" died down, the pace of standardization increased, and many new features came to the web.

In the last several years, a component-based model for web application development was popularized, and the JavaScript community blossomed with a wide variety of libraries and approaches. Work on standardizing the web’s native component model began at Google in 2012, and after several years of open development, was successfully implemented across all major browsers in 2019.

#### Technical Benefits

What if you could remove code, gain performance, and streamline implementation across everything you build? Web components provide this through the power of subtraction.

- Replace JavaScript you'd normally need to include by letting the browser handle things like [templating](https://www.w3.org/TR/html5/semantics-scripting.html#the-template-element), [style scoping](https://www.w3.org/TR/dom41/#shadow-trees), and [component model](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements).
- Increase your app's performance.
- Write using a streamlined component API that combines the best bits of popular libraries and frameworks!

##### Performance
Just like `querySelector` reduces developers' dependence on jQuery, the web components standards reduces the size and complexity of component libraries and frameworks. This ultimately benefits users by decreasing page load times and increasing app performance.

##### Future Proofing
Using the browser's standards-based component model will increase the longevity of your application. The web has an extremely strong tradition of backwards-compatibility. Standards bodies have consistently gone out of their way to maintain legacy APIs.

##### Flexibility
The web components standards are fairly low-level, letting library authors build upon them with innovative APIs. By using such libraries you can build your app in the style you want while still leveraging built-in browser features.

## Open, vs Go Fast

_"When driving conditions change, my map application adjusts to the faster route"_

_“Move fast and break things.”_  Zuckerberg

Being open doesn't mean slowing things down. Here's how we **go fast**, and still keep things open:

#### "Going Fast" as a catch-phrase:
We do this for fun - so let's use "go fast" as a _catch phrase for a sense of flow and confidence_. Pleasure then, is when our setup works for just that - how to go fast.

You won't come here and find yourself hobbled by a bunch of open. Let's get to work.

Where we _align_ with fatter platforms is that we also feel pretty good about going fast. 
So, where we might differ? -  We work to **_keep our options open_** to even faster stacks, even more fluid ways to work. The world evolves, we pattern ourselves to be nimble.

You **can** go fast, and still stay focused on the abstract goal: Going even faster! More below.

#### Open Discussion:
You'll find some pretty lively discussion in our slack channel! Does open discussion slow us down?

**_But first!_** We're delighted to point out that most of our discussion goes "Oh yeah, that wasn't clear. _Here's_ how to go fast with xyz-stack. Would you submit an issue for that?"

For discussion on stacks, by focusing on the comparative merits, [and following norms of shutting down personal attacks and trolling], our discussions end quickly, and move on to the next topic. **We don't tend to deliberate long** - we move on quickly and together, as consensus emerges.

#### Open Options:
We often lean towards a current default, such as Rollup for bundling. This way, there is one unambiguous recommendation for going fast.

But you'll often find other options listed - sometimes with considerations listed, such as when the other option is the best way to go fast.

Don't forget that our objectives are high level - again: go fast. It's not about sticking with one favorite stack.

#### Open Standards:
Just in case our embrace of standards comes across as less obvious than a love of going fast...

When you're experimenting, going fast means an external library to download with your app. We're good with that!
But n years later, when things kind of settle in on a pattern, it feels really crazy when we're **_still_** downloading an external library with a one-of API.

Standard browser libraries with standard APIs are faster, zero-weight, and easier to integrate with other tools. So we're always watching our favorite functionality sets, for advancing **that inevitable breakpoint** when the previously experimental approach becomes standardized.

Maybe open standards are just another way to go fast, for us.

#### Open, and Coupling:
Tight vs loose coupling is often cited as a go fast issue. The knee-jerk assumption? If you want to go fast, _tight coupling to [xyz stack] is a sure bet._

This assumption proves correct, only if you count the time it takes to familiarize yourself with a different but similar API, for example.
As a group, you'll find that we go fast but still like to **retarget our approach as we're going.** Even learning new API.

So it's a given that today's recommendations are just that - today's. We're always refactoring our apps from xyz-lib to foo-lib when better stacks come along, and we imagine that others are too. Using driving a car as an analogy - a dynamic map app, vs a static route map.

This touches on a bunch of design considerations that are too big for a page on philosophy, such as how to **design for components**, and **strategies for loose vs tight coupling.** We're smart enough to manage these design issues without feeling slowed down by them, and we assume that you are, too.

#### Open Tinkering:
Tinkering can be as fun as going fast, but only when it's in an individual's sandbox.

You'll find an **implicit contract** here - go fast is the rule, so committing back to open-wc means I've finished enough of the tinkering to enable the other guys to keep going fast.

And that means - such as with Rollup - we don't just provide a recommendation. The tinkerer commits back an **implementation for others** to use, whenever reasonable. And then we all try to keep that implementation functional, as others use it. Crowd sourcing, at it's best.

## Contribute

Feel free to critique, ask questions and join the conversation, we'd love to hear your opinions and feedback. You can reach us by creating an issue on our [github](https://github.com/open-wc) or on the [#open-wc](https://polymer.slack.com/messages/CE6D9DN05) channel in the [Polymer slack](https://join.slack.com/t/polymer/shared_invite/enQtNTAzNzg3NjU4ODM4LTkzZGVlOGIxMmNiMjMzZDM1YzYyMzdiYTk0YjQyOWZhZTMwN2RlNjM5ZDFmZjMxZWRjMWViMDA1MjNiYWFhZWM).
